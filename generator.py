# -*- coding:utf-8 -*-

# 生成器
# 通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表的容量肯定是有限的。
# 而且，创建一个包含100万个元素的列表，不仅占用很多的存储空间，如果我们仅仅需要访问前面的几个元素，那么后面绝大多数元素占用的空间就浪费了
# 所以，如果列表按照某种算法可以推算出来，那我们是否可以在循环的过程中不断推算出后面的元素呢？这样就不必创建完整的list
# 从而节省大量的空间
# 在python中，这种一边循环一边计算的机制，称为生成器

# 要创建一个generator，有很多种方法。
# 第一种方法很简单，只要把列表生成器的[]改成()，就可以创建一个generator
L = (x*x for x in range(1, 11))
print L
# 我们可以直接打印list的每一个元素，但我们怎么打印出generator的每一个元素呢？
# 如果要一个一个打印出来，可以通过generator的next()方法
print L.next()
print L.next()
# ...
# 计算到最后一个元素时，没有更多的元素时，抛出StopIteration的错误
# 要遍历整个generator，这种next()方法显然不适合，正确的方法是使用迭代，因为generator是可迭代对象
for i in L:
    print i
# 所以，我们创建了generator之后，基本上永远不会调用next()方法，而是通过for循环迭代它
# generator非常强大。如果推算的算法比较复杂，用类似列表生成式的for循环无法实现时，还可以用函数实现
# 比如，著名的斐波拉契数列1, 1, 2, 3, 5, 8, 13, 21, 34, ...
# 斐波拉契数列用列表生成式写不出来，但是，用函数打印出来却很容易
def fib(max):
    n, a, b = 0, 0, 1
    while n < max:
        print b
        a, b = b, a+b
        n += 1

fib(6)

# 仔细观察，可以看出，fib()函数实际上是定义了斐波拉契数列的推算规则
# 可以从第一个元素开始，推算出后续任意元素，这种逻辑非常类似generator
# 也就是说，上面的函数和generator仅一步之遥，要把fib()函数变成generator，只需要把print b改成yield b就行了
def fib(max):
    n, a, b = 0, 0, 1
    while n < max:
        yield b
        a, b = b, a+b
        n += 1

fib(6)
# 这就是定义generator的另外一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不是一个普通函数，而是一个generator
# 这里，最难理解的就是generator和函数的执行流程不一样
# 函数是顺序执行，遇到return语句或者最后一行就返回
# 而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句出继续执行
# 在fib()中，我们在循环过程中，不断调用yield，就会一直执行而不中断。
# 当然要给循环设置一个条件来退出循环，不然就会产生一个无限数列